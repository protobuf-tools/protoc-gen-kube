// Copyright 2021 The protobuf-tools Authors
// SPDX-License-Identifier: Apache-2.0

// Command protoc-gen-kube generates the Kubernetes controller APIs from Protocol Buffer schemas.
package main

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"

	"github.com/go-logr/logr"
	"github.com/go-logr/zapr"
	"github.com/spf13/pflag"
	"go.uber.org/zap"
	"k8s.io/gengo/args"
	klog "k8s.io/klog/v2"

	"github.com/protobuf-tools/protoc-gen-kube/pkg/generator/kubetype"
	"github.com/protobuf-tools/protoc-gen-kube/pkg/scanner"
	"github.com/protobuf-tools/protoc-gen-kube/pkg/version"
)

var flagVersion bool

func main() {
	if err := gen(); err != nil {
		fmt.Fprintf(os.Stderr, "protoc-gen-kube: %v\n", err)
	}
}

func gen() error {
	ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt)
	defer cancel()

	z, err := zap.NewDevelopment()
	if err != nil {
		return fmt.Errorf("create zap development logger: %w", err)
	}
	logf := zapr.NewLogger(z)
	ctx = logr.NewContext(ctx, logf)

	// inject third-party packages klog
	klog.SetLogger(logf)

	arguments := args.Default().WithoutDefaultFlagParsing() // WithoutDefaultFlagParsing is suck

	// setup flags
	pflag.BoolVarP(&flagVersion, "version", "v", false, fmt.Sprintf("print %s version", filepath.Base(os.Args[0])))
	arguments.AddFlags(pflag.CommandLine)
	pflag.Parse()

	if flagVersion {
		fmt.Fprintf(os.Stderr, "protoc-gen-kube@%s\n", version.Version())
		os.Exit(0)
	}

	// setup template
	arguments.GeneratedByCommentTemplate = `// Code generated by protoc-gen-kube. DO NOT EDIT.`
	arguments.GoHeaderFilePath = filepath.Join(args.DefaultSourceTree(), "hack/boilerplate/boilerplate.go.txt")

	// execute
	errc := make(chan error, 1)
	go func() {
		defer close(errc)

		if err := arguments.Execute(
			kubetype.NameSystems("", nil),
			kubetype.DefaultNameSystem(),
			(&scanner.Scanner{}).WithContext(ctx).Scan,
		); err != nil {
			errc <- fmt.Errorf("execute Generator: %w", err)
			return
		}

		logf.Info("completed successfully")
	}()

	select {
	case err := <-errc:
		if err != nil {
			return err
		}
	case <-ctx.Done():
		return ctx.Err()
	}

	return nil
}
